---
title: "LLSIM geostat"
output: bookdown::html_document2
date: "`r Sys.Date()`"
params:
  use_sets: TRUE
  fleets: !r c(1)
  species: 'bum'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  collapse = TRUE,
  comment = "#>",
  cache = TRUE,
  autodep = TRUE,
  fig.width = 7,
  fig.asp = 0.618,
  fig.pos = "ht",
  cache.comments = TRUE,
  dev = "png",
  dpi = 150
  # optipng = "-strip all"
)
# knitr::knit_hooks$set(optipng = knitr::hook_optipng)
```

```{r libs}
library(dplyr)
library(ggplot2)
library(sdmTMB)
theme_set(theme_light())
```

```{r check-us}
us_version <- identical(params$fleets, 1)
```

```{r read-dat}
if (params$use_sets) {
  dobs <- readr::read_csv("data-raw/obsset05.csv")
  dlog <- readr::read_csv("data-raw/logset05.csv")
} else {
  dobs <- readr::read_csv("data-raw/obstrip05.csv")
  dlog <- readr::read_csv("data-raw/logtrip05.csv")
}
names(dobs) <- tolower(names(dobs))
names(dlog) <- tolower(names(dlog))

if (params$use_sets) {
  dobs$bum <- dobs$c.bum
  dobs$swo <- dobs$c.swo
  dlog$bum <- dlog$c.bum
  dlog$swo <- dlog$c.swo
}

dobs$bycatch <- dobs[[params$species]]
dlog$bycatch <- dlog[[params$species]]
```

```{r filter-fleet}
dobs <- filter(dobs, fleet %in% params$fleets)
dlog <- filter(dlog, fleet %in% params$fleets)
```

FIXME?

```{r filter-us}
if (us_version) {
  dobs <- filter(dobs, lon < 0, lat > -20)
  dlog <- filter(dlog, lon < 0, lat > -20)
}
```


```{r sf-map-dat, warning=FALSE}
map_data <- rnaturalearth::ne_countries(
  scale = "small",
  returnclass = "sf"
)
map_data_cropped <- sf::st_crop(
  sf::st_make_valid(map_data),
  c(
    xmin = min(dlog$lon) - 30, ymin = min(dlog$lat) - 10,
    xmax = max(dlog$lon) + 10, ymax = max(dlog$lat) + 10
  )
)
```

<https://desktop.arcgis.com/en/arcmap/latest/map/projections/equidistant-conic.htm>
<https://en.wikipedia.org/wiki/Equidistant_conic_projection>

```{r project}
if (us_version) { # US only
  equidistant_conic <- paste0(
    "+proj=eqdc +lat_0=0 +lon_0=-20 +lat_1=-10 ",
    "+lat_2=40 +x_0=0 +y_0=0 +datum=WGS84 +units=km +no_defs"
  )
} else {
  equidistant_conic <- paste0(
    "+proj=eqdc +lat_0=0 +lon_0=-20 +lat_1=-30 ",
    "+lat_2=35 +x_0=0 +y_0=0 +datum=WGS84 +units=km +no_defs"
  )
}

map_data_proj <- sf::st_transform(map_data_cropped, crs = equidistant_conic)

project_dat <- function(x, crs, mult) {
  x_sf <- sf::st_as_sf(x, coords = c("lon", "lat"), crs = "WGS84") |>
    sf::st_transform(x, crs = crs)
  xy <- sf::st_coordinates(x_sf)
  xy <- mutate(as.data.frame(xy), X = X * mult, Y = Y * mult)
  x$X <- xy$X
  x$Y <- xy$Y
  list(dat_sf = x_sf, dat_sdmTMB = x)
}

temp <- project_dat(dobs, equidistant_conic, mult = 0.01)
dobs_sf <- temp$dat_sf
dobs <- temp$dat_sdmTMB

temp <- project_dat(dlog, equidistant_conic, mult = 0.01)
dlog_sf <- temp$dat_sf
dlog <- temp$dat_sdmTMB
```

```{r plot-dat-map-log}
ggplot() +
  geom_sf(data = map_data_proj) +
  geom_sf(data = dlog_sf, size = 0.2, alpha = 0.2) +
  geom_sf(data = dobs_sf, size = 0.2, alpha = 0.2, colour = "red") +
  coord_sf(expand = FALSE)
```

```{r plot-dat-bycatch-year}
# bounding_ylim <- range(dlog$lat) + c(-10, 10)
# bounding_xlim <- range(dlog$lon) + c(-10, 20)
#
# rectangle <- sf::st_sfc(
#   sf::st_point(bounding_xlim),
#   sf::st_point(bounding_ylim),
#   crs = 4326
# ) |>
#   sf::st_transform(crs = equidistant_conic)
# rec <- sf::st_coordinates(rectangle)

# map_data_cropped <- sf::st_crop(
#   sf::st_make_valid(map_data_proj),
#     c(xmin = rec[1,1], ymin = rec[1,2],
#       xmax = rec[2,1], ymax = rec[2,2]
# ))

ggplot() +
  # geom_sf(data = map_data_cropped) +
  geom_point(
    data = dobs, size = 0.8,
    mapping = aes(colour = bycatch, x = lon, y = lat)
  ) +
  # coord_sf(expand = FALSE) +
  coord_fixed() +
  # coord_sf(default_crs = equidistant_conic,
  # ylim = rec[,'Y'], xlim = rec[,'X']) +
  facet_wrap(vars(year)) +
  scale_colour_viridis_c(trans = "log10")
```

```{r factorize}
factorize <- function(x) {
  x$light_f <- as.factor(x$light)
  x$season_f <- as.factor(x$season)
  x$year_f <- as.factor(x$year)
  x
}
dobs <- factorize(dobs)
dlog <- factorize(dlog)
```

```{r grid}
grid <- select(dlog, X, Y) |> distinct()
nrow(grid)
grid_all <- purrr::map_dfr(sort(unique(dlog$year)), function(x) {
  bind_cols(tibble(year = x), grid)
})
grid_all <- left_join(grid_all, distinct(select(dlog, X, Y, lon, lat)))
grid_all$month <- 6
grid_all$light_f <- sort(unique(dobs$light_f))[1]
grid_all$season_f <- sort(unique(dobs$season_f))[1]
grid_all$hbf <- mean(dobs$hbf)
grid_all$year_f <- as.factor(grid_all$year)
nrow(grid_all)
```

combine both; could be just one or the other

```{r mesh}
dall <- bind_rows(select(dobs, X, Y), select(dlog, X, Y))
mesh_all <- make_mesh(dall, c("X", "Y"), n_knots = 400) # cutoff?
mesh <- make_mesh(dobs, c("X", "Y"), mesh = mesh_all$mesh)
# mesh$mesh$n
```

```{r mesh-gg}
# plot(mesh$mesh, asp = 1, main = NULL)
# points(dobs$X ,dobs$Y, pch = ".", col = "red")
ggplot() +
  geom_point(data = dobs, mapping = aes(X, Y), alpha = 0.2) +
  inlabru::gg(mesh$mesh) +
  coord_fixed()
```

```{r check-data}
table(dobs$light_f)
table(dobs$year_f)
table(dobs$season_f)

# make sure there aren't years with 100% or 0% observations:
group_by(dobs, year) |>
  summarise(pos_swo = mean(swo > 0), pos_bum = mean(bum > 0), n = n()) |>
  as.data.frame()

# table(dobs$year, dobs$season)
# table(dobs$year, dobs$light_f)
# table(dobs$light_f, dobs$season_f)
```

Anisotropy: 

Priors...

Barriers...

versions without any fields or comparison?

random walk on year?

```{r cache-check, echo=FALSE}
files_base <- c(
  "fit-nb2-sp",
  "fit-dg-sp",
  "fit-dl-sp",
  "fit-dnb2-sp"
)
files_base <- paste0(params$species, "-", files_base)
files <- paste0(here::here("data-generated/"), files_base, ".rds")
do_fit <- any(!file.exists(files))
```

```{r fit1, results='hide', eval=do_fit}
if (us_version) {
  .spatiotemporal <- "iid"
} else {
  .spatiotemporal <- "off"
}

fit_nb2 <- sdmTMB(
  bycatch ~ 0 + year_f + season_f + log(hbf) + light_f,
  data = dobs,
  mesh = mesh,
  family = nbinom2(),
  time = "year",
  offset = log(dobs$hooks),
  spatial = "on",
  anisotropy = TRUE,
  spatiotemporal = .spatiotemporal,
  control = sdmTMBcontrol(newton_loops = 1L),
  silent = FALSE
)
# m_tw <- update(fit_nb2, family = tweedie())
fit_dg <- update(fit_nb2, family = delta_gamma())
fit_dl <- update(fit_nb2, family = delta_lognormal())
fit_dnb2 <- update(fit_nb2, family = delta_truncated_nbinom2())
```

```{r saverds, eval=do_fit, echo=FALSE}
saveRDS(fit_nb2, files[1])
saveRDS(fit_dg, files[2])
saveRDS(fit_dl, files[3])
saveRDS(fit_dnb2, files[4])
```

```{r readrds, eval=!do_fit, echo=FALSE}
fit_nb2 <- readRDS(files[1])
fit_dg <- readRDS(files[2])
fit_dl <- readRDS(files[3])
fit_dnb2 <- readRDS(files[4])
```

```{r pring-nb2}
print(fit_nb2)
sanity(fit_nb2)
```

```{r print-dg}
print(fit_dg)
sanity(fit_dg)
```

```{r print-dl}
print(fit_dl)
sanity(fit_dl)
```

```{r print-dnb2}
print(fit_dnb2)
sanity(fit_dnb2)
```

```{r aic}
AIC(fit_nb2, fit_dg, fit_dl, fit_dnb2)
```

Could do cross validation with `sdmTMB_cv()`, but will not be fast here.

```{r plot-aniso}
sdmTMB:::plot_anisotropy2(fit_nb2)
sdmTMB:::plot_anisotropy2(fit_dg)
sdmTMB:::plot_anisotropy2(fit_dl)
sdmTMB:::plot_anisotropy2(fit_dnb2)
```

```{r ggeffect, eval=FALSE}
# ggeffects::ggeffect(fit_nb2, terms = "light_f") |> plot()
# ggeffects::ggeffect(fit_nb2, terms = "season_f") |> plot()
# ggeffects::ggeffect(fit_nb2, terms = "year_f") |> plot()
# ggeffects::ggeffect(fit_nb2, terms = "hbf") |> plot()
```

```{r quant-resids}
plot_resids <- function(x) {
  r <- residuals(x)
  qqnorm(r)
  qqline(r)
}
plot_resids(fit_nb2)
plot_resids(fit_dg)
plot_resids(fit_dl)
plot_resids(fit_dnb2)
```

Warning...

```{r dharma, eval=FALSE}
plot_dharma_resids <- function(x) {
  s <- simulate(x, nsim = 100L)
  dharma_residuals(s, x)
}
plot_dharma_resids(fit_nb2)
plot_dharma_resids(fit_dg)
plot_dharma_resids(fit_dl)
```

MCMC resids, slowest

```{r mcmc-resids, eval=FALSE}
r_mcmc <- residuals(
  fit_nb2,
  type = "mle-mcmc",
  mcmc_warmup = 100, mcmc_iter = 200
)
```

```{r}
dobs$resid <- residuals(fit_dl)
dobs |>
  ggplot(aes(lon, lat, colour = resid)) +
  geom_point(size = 0.4) +
  facet_wrap(~year) +
  scale_colour_gradient2() +
  coord_equal()
```

```{r predict-on-grid}
p_grid <- predict(fit_nb2, newdata = grid_all)
```

```{r plot-map-func}
plot_map <- function(dat, column = est) {
  ggplot(dat, aes(lon, lat, fill = {{ column }})) +
    geom_raster() +
    facet_wrap(~year) +
    coord_fixed()
}
```

```{r plot-est}
plot_map(p_grid, exp(est)) +
  scale_fill_viridis_c(trans = "sqrt")
```

```{r plot-est2}
p_grid |>
  filter(year %in% range(p_grid$year)) |> # pick two
  plot_map(exp(est)) +
  scale_fill_viridis_c(trans = "sqrt")
```

```{r plot-omega}
p_grid |>
  filter(year == min(p_grid$year)) |> # pick one
  plot_map(omega_s) +
  scale_fill_gradient2()
```

```{r plot-eps, eval="epsilon_st" %in% names(p_grid)}
p_grid |>
  plot_map(epsilon_st) +
  scale_fill_gradient2()
```

```{r check-sim-zero}
# s <- simulate(fit_nb2, nsim = 100L)
# mean(s == 0)
# mean(dobs$swo == 0)
```

```{r plot-cv}
pred <- predict(fit_dl, newdata = grid_all, nsim = 100)
grid_all$cv <- apply(pred, 1, function(x) sd(exp(x)) / mean(exp(x)))

filter(grid_all, year == min(dobs$year)) |> # picking one
  ggplot(aes(lon, lat, fill = cv)) +
  geom_raster() +
  scale_fill_viridis_c(option = "A", trans = "log10") +
  coord_equal()
```

```{r cache-check-index, echo=FALSE}
index_file <- here::here("data-generated", paste0(params$species, "-", "index.rds"))
do_calc_index <- !file.exists(index_file)
```

```{r calc-indices, eval=do_calc_index}
calculate_index <- function(x) {
  pred <- predict(x,
    newdata = dlog,
    offset = log(dlog$hooks), return_tmb_object = TRUE
  )
  ind <- sdmTMB::get_index(pred, bias_correct = TRUE)
  ind
}
models <- list(fit_nb2, fit_dg, fit_dl, fit_dnb2)
names(models) <- c("NB2", "Delta-lognormal", "Delta-Gamma", "Delta-NB2")
ind <- purrr::map_dfr(models, calculate_index, .id = "model")
```

```{r saverds-index, eval=do_calc_index, echo=FALSE}
saveRDS(ind, index_file)
```

```{r readrds-index, eval=!do_calc_index, echo=FALSE}
ind <- readRDS(index_file)
```

```{r plot-indices}
true <- group_by(dlog, year) |>
  summarize(swo = sum(swo), bum = sum(bum),
    type = "simulated", model = "simulated")
true$est <- true[[params$species]]

# both <- left_join(
#   select(dobs, year, month, lat, lon, hooks, bum, swo),
#   distinct(select(dlog, year, month, lat, lon, hooks, bum, swo))
#   )
# nrow(both)
# nrow(dobs)

temp <- ind |>
  mutate(type = "predicted") |>
  bind_rows(true)

temp |>
  ggplot(aes(year, est,
    ymin = lwr, ymax = upr, lty = type,
    colour = model, fill = model
  )) +
  geom_ribbon(alpha = 0.5, colour = NA) +
  geom_line() +
  ylab("Bycatch total") +
  xlab("Year") +
  labs(lty = "Type") +
  scale_color_brewer(palette = "Set2")

temp |>
  filter(model != "NB2") |>
  ggplot(aes(year, est,
    ymin = lwr, ymax = upr, lty = type,
    colour = model, fill = model
  )) +
  geom_ribbon(alpha = 0.5, colour = NA) +
  geom_line() +
  ylab("Bycatch total") +
  xlab("Year") +
  labs(colour = "Model", fill = "Model") +
  scale_color_brewer(palette = "Set2")

# raw coverage
left_join(ind, select(true, year, true = est)) |>
  mutate(
    covered = true < upr & true > lwr
  ) |>
  group_by(model) |>
  summarise(coverage = mean(covered))

temp <- left_join(ind, select(true, year, true = est)) |>
  group_by(model) |>
  mutate(
    geomean = exp(mean(log(est))),
    true_geomean = exp(mean(log(true)))
  ) |>
  mutate(
    upr = upr / geomean,
    lwr = lwr / geomean,
    est = est / geomean,
    true = true / true_geomean
  )

temp |>
  ggplot(aes(year, est, colour = model, fill = model)) +
  geom_line() +
  geom_ribbon(aes(ymin = lwr, ymax = upr), alpha = 0.5, colour = NA) +
  geom_line(aes(y = true), lty = 2) +
  ylab("Centered predicted bycatch") +
  xlab("Year") +
  labs(colour = "Model", fill = "Model") +
  scale_color_brewer(palette = "Set2")

# centered coverage
temp |>
  group_by(model) |>
  mutate(covered = true < upr & true > lwr) |>
  group_by(model) |>
  summarise(coverage = mean(covered))
```

How much easy to read code vs. work for many scenarios in a report?
One thoroughly or a report for each scenario or in between? 1 in depth, do the others without explanation?

e.g. explore aniso vs. none, families etc.
could do efficiently - hard to read code
or do a few with easy to read code
