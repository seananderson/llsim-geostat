---
title: "LLSIM geostat"
output: bookdown::html_document2
date: "`r Sys.Date()`"
params:
  use_sets: TRUE
  fleets: !r c(1, 2, 3)
  species: 'bum'
  spatiotemporal: "iid"
  spatial: "on"
  share_range: TRUE
---

## TODO

- [ ] add version without spatial/spatiotemporal for comparison
- [ ] add basic explanation below
- [ ] figure out nice figs for main writeup
- [ ] one nice appendix?
- [ ] compare to Beth's using same metrics?
- [ ] maybe take the time to run the spatiotemporal all models
- [ ] make projected plot not look laughable

## Conclusions

- seems to need flexibility of a delta model
- Tweedie often doesn't converge here
- NB2 can be wildly off high or low
- seems to be some anisotropy... but think about projection
- coverage seems a bit low for SWO and a bit high for BUM
- spatiotemporal component often shrinks to zero for the much rarer BUM bycatch

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  collapse = TRUE,
  comment = "#>",
  cache = TRUE,
  autodep = TRUE,
  fig.width = 9,
  fig.asp = 0.618,
  out.width = "80%",
  fig.pos = "ht",
  cache.comments = TRUE,
  dev = "png",
  dpi = 150
  # optipng = "-strip all"
)
# knitr::knit_hooks$set(optipng = knitr::hook_optipng)
```

```{r libs}
library(dplyr)
library(ggplot2)
library(sdmTMB)
theme_set(theme_light())
```

```{r check-us}
us_version <- identical(params$fleets, 1)
```

```{r read-dat}
if (params$use_sets) {
  dobs <- readr::read_csv("data-raw/obsset05.csv")
  dlog <- readr::read_csv("data-raw/logset05.csv")
} else {
  dobs <- readr::read_csv("data-raw/obstrip05.csv")
  dlog <- readr::read_csv("data-raw/logtrip05.csv")
}
names(dobs) <- tolower(names(dobs))
names(dlog) <- tolower(names(dlog))

if (params$use_sets) {
  dobs$bum <- dobs$c.bum
  dobs$swo <- dobs$c.swo
  dlog$bum <- dlog$c.bum
  dlog$swo <- dlog$c.swo
}

dobs$bycatch <- dobs[[params$species]]
dlog$bycatch <- dlog[[params$species]]
```

```{r filter-fleet}
dobs <- filter(dobs, fleet %in% params$fleets)
dlog <- filter(dlog, fleet %in% params$fleets)
```

Explain large spatial outliers

```{r filter-us}
if (us_version) {
  dobs <- filter(dobs, lon < 0, lat > -20)
  dlog <- filter(dlog, lon < 0, lat > -20)
}
```

<https://desktop.arcgis.com/en/arcmap/latest/map/projections/equidistant-conic.htm>
<https://en.wikipedia.org/wiki/Equidistant_conic_projection>

Go back to Albers?

```{r project}
if (us_version) { # US only
  conic <- paste0(
    "+proj=eqdc +lat_0=0 +lon_0=-20 +lat_1=-10 ",
    "+lat_2=40 +x_0=0 +y_0=0 +datum=WGS84 +units=km +no_defs"
  )
} else {
  conic <- paste0(
    "+proj=eqdc +lat_0=0 +lon_0=-20 +lat_1=-30 ",
    "+lat_2=35 +x_0=0 +y_0=0 +datum=WGS84 +units=km +no_defs"
  )
}
if (us_version) { # US only
  albers <- paste0(
    "+proj=aea +lat_0=0 +lon_0=-20 +lat_1=-10 ",
    "+lat_2=40 +x_0=0 +y_0=0 +datum=NAD83 +units=km +no_defs"
  )
} else {
  albers <- paste0(
    "+proj=aea +lat_0=0 +lon_0=-20 +lat_1=-30 ",
    "+lat_2=35 +x_0=0 +y_0=0 +datum=NAD83 +units=km +no_defs"
  )
}

project_dat <- function(x, crs, mult) {
  x_sf <- sf::st_as_sf(x, coords = c("lon", "lat"), crs = "WGS84") |>
    sf::st_transform(x, crs = crs)
  xy <- sf::st_coordinates(x_sf)
  xy <- mutate(as.data.frame(xy), X = X * mult, Y = Y * mult)
  x$X <- xy$X
  x$Y <- xy$Y
  list(dat_sf = x_sf, dat_sdmTMB = x)
}

.crs <- albers
# .csr <- conic
# .crs <- 32626
temp <- project_dat(dobs, .crs, mult = 0.01)
dobs_sf <- temp$dat_sf
dobs <- temp$dat_sdmTMB

temp <- project_dat(dlog, .crs, mult = 0.01)
dlog_sf <- temp$dat_sf
dlog <- temp$dat_sdmTMB
```

```{r plot-dat-map-log}
map_data <- rnaturalearth::ne_countries(
  scale = "small",
  returnclass = "sf"
)
map_data_cropped <- sf::st_crop(
  sf::st_make_valid(map_data),
  c(
    xmin = min(dlog$lon) - 20, ymin = min(dlog$lat) - 20,
    xmax = max(dlog$lon) + 20, ymax = max(dlog$lat) + 20
  )
)

gg_coord <- coord_sf(expand = FALSE, crs = "WGS84",
    xlim = c(range(dlog$lon) + c(-5, 5)),
    ylim = c(range(dlog$lat) + c(-5, 5))
  )

ggplot() +
  geom_sf(data = map_data_cropped, colour = "grey60", fill = "grey60") +
  geom_sf(data = dlog_sf, size = 0.2, alpha = 0.2) +
  geom_sf(data = dobs_sf, size = 0.2, alpha = 0.2, colour = "red") +
  gg_coord
```

```{r plot-dat-bycatch-year, echo=FALSE}
ggplot() +
  geom_sf(data = map_data_cropped) +
  geom_point(
    data = dobs, size = 0.8,
    mapping = aes(colour = bycatch, x = lon, y = lat)
  ) +
  gg_coord +
  facet_wrap(vars(year)) +
  scale_colour_viridis_c(trans = "log10")
```

```{r factorize}
factorize <- function(x) {
  x$light_f <- as.factor(x$light)
  x$season_f <- as.factor(x$season)
  x$year_f <- as.factor(x$year)
  x
}
dobs <- factorize(dobs)
dlog <- factorize(dlog)
```

```{r grid}
grid <- select(dlog, X, Y) |> distinct()
nrow(grid)
grid_all <- purrr::map_dfr(sort(unique(dlog$year)), function(x) {
  bind_cols(tibble(year = x), grid)
})
grid_all <- left_join(grid_all, distinct(select(dlog, X, Y, lon, lat)))
grid_all$month <- 6
grid_all$light_f <- sort(unique(dobs$light_f))[1]
grid_all$season_f <- sort(unique(dobs$season_f))[1]
grid_all$hbf <- mean(dobs$hbf)
grid_all$year_f <- as.factor(grid_all$year)
nrow(grid_all)
```

combine both; could be just one or the other

```{r mesh}
dall <- bind_rows(select(dobs, X, Y), select(dlog, X, Y))
knots <- 300
mesh_all <- make_mesh(dall, c("X", "Y"), n_knots = knots) # cutoff?
mesh <- make_mesh(dobs, c("X", "Y"), mesh = mesh_all$mesh)
# mesh$mesh$n
```

```{r mesh-gg}
# plot(mesh$mesh, asp = 1, main = NULL)
# points(dobs$X ,dobs$Y, pch = ".", col = "red")
ggplot() +
  geom_point(data = dobs, mapping = aes(X, Y), alpha = 0.2) +
  inlabru::gg(mesh$mesh) +
  coord_fixed() +
  theme_light()
```

```{r theme-light, echo=FALSE}
theme_set(theme_light())
```

```{r check-data, eval=FALSE, echo=FALSE}
table(dobs$light_f)
table(dobs$year_f)
table(dobs$season_f)

# make sure there aren't years with 100% or 0% observations:
group_by(dobs, year) |>
  summarise(pos_swo = mean(swo > 0), pos_bum = mean(bum > 0), n = n()) |>
  as.data.frame()
```

Anisotropy: 

Priors...

Barriers...

versions without any fields or comparison?

random walk on year?

```{r cache-check, echo=FALSE}
file_name_maker <- function(type, fleet, family, sp, st, knots, share_range) {
  f <- paste(type, fleet, family, "sp", sp, "st", st, "knots", knots, "share_range", share_range, sep = "-")
  here::here("data-generated", paste0(f, ".rds"))
}
fleet <- if (us_version) "us" else "all"
files <- file_name_maker(type = 'fit', fleet = fleet, 
  family = c("nb2", "dg", "dl"), 
  sp = 'on', st = params$spatiotemporal, knots = knots, share_range = params$share_range)
do_fit <- any(!file.exists(files))
message(do_fit)
```

```{r fit1, results='hide', eval=do_fit}
tictoc::tic()
fit_nb2 <- sdmTMB(
  bycatch ~ year_f + season_f + hbf + light_f,
  data = dobs,
  mesh = mesh,
  family = nbinom2(),
  time = "year",
  offset = log(dobs$hooks),
  spatial = params$spatial,
  spatiotemporal = params$spatiotemporal,
  share_range = params$share_range,
  anisotropy = TRUE,
  control = sdmTMBcontrol(newton_loops = 1),
  silent = FALSE
)
tictoc::toc()

# m_tw <- update(fit_nb2, formula = bycatch ~ year_f + season_f, spatiotemporal = "off", family = tweedie())
tictoc::tic()
fit_dg <- update(fit_nb2, family = delta_gamma())
tictoc::toc()

tictoc::tic()
fit_dl <- update(fit_nb2, family = delta_lognormal())
tictoc::toc()
# fit_dnb2 <- update(fit_nb2, family = delta_truncated_nbinom2())
```

```{r saverds, eval=do_fit, echo=FALSE}
saveRDS(fit_nb2, files[1])
saveRDS(fit_dg, files[2])
saveRDS(fit_dl, files[3])
# saveRDS(fit_dnb2, files[4])
```

```{r readrds, eval=!do_fit, echo=FALSE}
fit_nb2 <- readRDS(files[1])
fit_dg <- readRDS(files[2])
fit_dl <- readRDS(files[3])
# fit_dnb2 <- readRDS(files[4])
```

```{r pring-nb2, message=TRUE}
print(fit_nb2)
sanity(fit_nb2)
```

```{r print-dg, message=TRUE}
print(fit_dg)
sanity(fit_dg)
```

```{r print-dl, message=TRUE}
print(fit_dl)
sanity(fit_dl)
```

```{r aic}
AIC(fit_nb2, fit_dg, fit_dl) |> 
  arrange(AIC)
```

Could do cross validation with `sdmTMB_cv()`, but will not be fast here.

```{r plot-aniso, out.width="60%"}
sdmTMB:::plot_anisotropy2(fit_nb2)
sdmTMB:::plot_anisotropy2(fit_dg)
sdmTMB:::plot_anisotropy2(fit_dl)
```

```{r ggeffect, eval=FALSE, echo=FALSE}
# ggeffects::ggeffect(fit_nb2, terms = "light_f") |> plot()
# ggeffects::ggeffect(fit_nb2, terms = "season_f") |> plot()
# ggeffects::ggeffect(fit_nb2, terms = "year_f") |> plot()
# ggeffects::ggeffect(fit_nb2, terms = "hbf") |> plot()
```

```{r quant-resids, out.width="40%", fig.width=5}
plot_resids <- function(x) {
  r <- residuals(x)
  qqnorm(r)
  qqline(r)
}
plot_resids(fit_nb2)
plot_resids(fit_dg)
plot_resids(fit_dl)
```

Warning...

```{r dharma, eval=FALSE}
plot_dharma_resids <- function(x) {
  s <- simulate(x, nsim = 200L)
  dharma_residuals(s, x)
}
plot_dharma_resids(fit_nb2)
plot_dharma_resids(fit_dg)
plot_dharma_resids(fit_dl)
```

MCMC resids, slowest

```{r mcmc-resids, eval=FALSE}
r_mcmc <- residuals(
  fit_nb2,
  type = "mle-mcmc",
  mcmc_warmup = 100, mcmc_iter = 200
)
```

```{r spatial-residuals}
dobs$resid <- residuals(fit_dl)
dobs |>
  filter(year %in% c(1990, 2000, 2015)) |> # pick a few
  ggplot(aes(lon, lat, colour = resid)) +
  geom_point(size = 0.8, position = position_jitter(width = 0.25, height = 0.25)) +
  facet_wrap(~year) +
  scale_colour_gradient2() +
  coord_equal()
```

```{r predict-on-grid}
p_grid <- predict(fit_dl, newdata = grid_all)
```

```{r plot-map-func}
plot_map <- function(dat, column = est) {
  g <- ggplot(dat, aes(lon, lat, fill = {{ column }})) +
    geom_raster() +
    coord_fixed()
  if (length(unique(dat$year)) > 1) g <- g + facet_wrap(vars(year))
  g
}
```

```{r plot-est}
plot_map(p_grid, plogis(est1) * exp(est2)) +
  scale_fill_viridis_c(trans = "sqrt")
```

```{r plot-est-zoom}
p_grid |>
  filter(year %in% c(1990, 2000, 2015)) |> # pick a few
  plot_map(plogis(est1) * exp(est2)) +
  scale_fill_viridis_c(trans = "sqrt")
```

```{r plot-est1}
plot_map(p_grid, plogis(est1)) +
  scale_fill_viridis_c(option = "C")
```

```{r plot-est2}
plot_map(p_grid, exp(est2)) +
  scale_fill_viridis_c(option = "D", trans = "sqrt")
```

```{r plot-omega1}
p_grid |>
  filter(year == min(p_grid$year)) |> # pick any one
  plot_map(omega_s1) +
  scale_fill_gradient2()
```

```{r plot-omega2}
p_grid |>
  filter(year == min(p_grid$year)) |> # pick any one
  plot_map(omega_s2) +
  scale_fill_gradient2()
```

```{r plot-eps1, eval="epsilon_st1" %in% names(p_grid)}
p_grid |>
  plot_map(epsilon_st1) +
  scale_fill_gradient2()
```

```{r plot-eps2, eval="epsilon_st1" %in% names(p_grid)}
p_grid |>
  plot_map(epsilon_st2) +
  scale_fill_gradient2()
```

```{r check-sim-zero}
# s <- simulate(fit_nb2, nsim = 100L)
# mean(s == 0)
# mean(dobs$swo == 0)
```

```{r plot-cv}
pred <- predict(fit_dl, newdata = grid_all, nsim = 100)
grid_all$cv <- apply(pred, 1, function(x) sd(exp(x)) / mean(exp(x)))

filter(grid_all, year %in% c(2000)) |> # pick one; very similar
  ggplot(aes(lon, lat, fill = cv)) +
  geom_raster() +
  scale_fill_viridis_c(option = "A", trans = "log10") +
  coord_equal() +
  facet_wrap(~year)
```

```{r cache-check-index, echo=FALSE}
index_file <- file_name_maker(type = 'index', fleet = fleet,
  family = c("all"), 
  sp = 'on', st = params$spatiotemporal, knots = knots, share_range = params$share_range)
do_calc_index <- !file.exists(index_file)
```

```{r models-list}
models <- list(fit_nb2, fit_dg, fit_dl)
names(models) <- c("NB2", "Delta-lognormal", "Delta-Gamma")
```

```{r calc-indices, eval=do_calc_index}
calculate_index <- function(x) {
  pred <- predict(x,
    newdata = dlog,
    offset = log(dlog$hooks), return_tmb_object = TRUE
  )
  ind <- sdmTMB::get_index(pred, bias_correct = TRUE)
  ind
}
tictoc::tic()
ind <- purrr::map_dfr(models, calculate_index, .id = "model")
tictoc::toc()
```

```{r saverds-index, eval=do_calc_index, echo=FALSE}
saveRDS(ind, index_file)
```

```{r readrds-index, eval=!do_calc_index, echo=FALSE}
ind <- readRDS(index_file)
```

```{r plot-indices-prep, echo=FALSE}
true <- group_by(dlog, year) |>
  summarize(swo = sum(swo), bum = sum(bum),
    type = "simulated", model = "simulated")
true$est <- true[[params$species]]

temp <- ind |>
  mutate(type = "predicted")

temp <- temp |> group_by(model) |> 
  mutate(
    any_not_converged = 
      sum(is.infinite(upr)) > 0 | sum(lwr == 0) > 0
    ) |> 
  filter(!any_not_converged)

temp <- temp |>
  bind_rows(true)
```

```{r plot-indices, echo=FALSE}
cols <- RColorBrewer::brewer.pal(length(models), "Dark2")
names(cols) <- names(models)
cols <- c(cols, c("simulated" = "#000000"))

gg_scales <- list(scale_color_manual(values = cols),
  scale_fill_manual(values = cols),
  scale_linetype_manual(values = c("predicted" = 1, "simulated" = 2)),
  coord_cartesian(ylim = c(0, NA)))

gg_labs <- list(ylab("Bycatch total"),
  xlab("Year"),
  labs(lty = "Type", colour = "Model", fill = "Model"))

temp |>
  filter(model != "simulated") |> 
  ggplot(aes(year, est,
    ymin = lwr, ymax = upr, lty = type,
    colour = model, fill = model
  )) +
  geom_ribbon(alpha = 0.5, colour = NA) +
  geom_line() +
  geom_line(data = true |> select(-model), lty = 2, colour = "black", 
    inherit.aes = FALSE, mapping = aes(year, est)) +
  gg_scales +
  gg_labs +
  facet_wrap(vars(model), scales = "free_y", nrow = 2)

temp |>
  ggplot(aes(year, est,
    ymin = lwr, ymax = upr, lty = type,
    colour = model, fill = model
  )) +
  geom_ribbon(alpha = 0.5, colour = NA) +
  geom_line() +
  gg_scales +
  gg_labs
```

```{r coverage-raw}
left_join(ind, select(true, year, true = est)) |>
  mutate(
    covered = true < upr & true > lwr
  ) |>
  group_by(model) |>
  summarise(coverage = mean(covered))

left_join(ind, select(true, year, true = est)) |>
  mutate(upr = exp(log_est + qnorm(0.75) * se), lwr = exp(log_est + qnorm(0.25) * se)) |> 
  mutate(
    covered = true < upr & true > lwr
  ) |>
  group_by(model) |>
  summarise(coverage = mean(covered))
```

```{r centered, eval=FALSE, echo=FALSE}
temp <- left_join(ind, select(true, year, true = est)) |>
  group_by(model) |>
  mutate(
    geomean = exp(mean(log(est))),
    true_geomean = exp(mean(log(true)))
  ) |>
  mutate(
    upr = upr / geomean,
    lwr = lwr / geomean,
    est = est / geomean,
    true = true / true_geomean
  )

temp |>
  ggplot(aes(year, est, colour = model, fill = model)) +
  geom_line() +
  geom_ribbon(aes(ymin = lwr, ymax = upr), alpha = 0.5, colour = NA) +
  geom_line(aes(y = true), lty = 2) +
  gg_labs +
  gg_scales +
  ylab("Centered bycatch")

# centered coverage
temp |>
  group_by(model) |>
  mutate(covered = true < upr & true > lwr) |>
  group_by(model) |>
  summarise(coverage = mean(covered))
```
